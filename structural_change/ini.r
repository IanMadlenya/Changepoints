#通过查看?igraph.plotting 了解详细画图参数

# generate a complete graph and its layout
generate.ug <- function(d,Plot=TRUE){
    #d: number of vertices
    v <- paste("v",1:d,sep = "")
    ug <- graph.edgelist(matrix(letters[combinations(d,2)],ncol = 2),directed = FALSE)
    if(Plot) plot(ug)
    list(ug=ug,lyt=layout.auto(ug))
}
# select a random edge, used in initial.ug() toogle.move() and fork.move()
# !!!NULL edge must be included!!!
# Talih 4.1.4
random.edge <- function(edge.idx){
    l <- length(edge.idx)
    selection <- ceiling(runif(1,min=0,max=l+1))
    if(selection<=l){
        edge.idx[selection] <- xor(edge.idx[selection],TRUE)
        return(edge.idx)}
    else
        return(edge.idx)
}

# initialize graph list from a complete graph
initial.ug <- function(g,lout,b1,B,Plot=FALSE){
    #g: complete graph, generated by generate.ug()
    #lout: layout, generated by generate.ug()
    #b1: number of edges at block 1
    #B: number of blocks
    ne <- length(E(g))
    idx <- rep(FALSE,ne)
    idx[sample(ne,b1)] <- TRUE
    g1 <- subgraph.edges(g,(1:ne)[idx],delete.vertices = FALSE)
    glist <- list(g1)
    ilist <- list(idx)
    for(i in 2:B){
        idx <- random.edge(idx)
        glist <- c(glist,list(subgraph.edges(g,(1:ne)[idx],delete.vertices=FALSE)))
        ilist <- c(ilist,list(idx))
    }
    if(Plot){
        par(mfcol = c(ceiling(sqrt(B)),ceiling(sqrt(B))))
        for(i in 1:B) plot(glist[[i]],layout=lout,main=i)}
    list(glist=glist,ilist=ilist)
}

# plot graph list
plot.g <- function(complete,g,B){
    par(mfcol = c(ceiling(sqrt(B)),ceiling(sqrt(B))))
    for(i in 1:B) plot(g$glist[[i]],layout=complete$lyt,main=i)
}



if(FALSE){
# Accept-Reject method
# used to generate simulated samples
accept.reject.simple <- function(Ex,d,Theta,Sigma2,n.sample=1000){
    #Ex: expression returned by graph.model.simple()
    #d: number of vertices
    #Theta: parameter theta
    #Sigma2: parameter sigma square
    M <- -(optim(par = rep(0,d),fn = function(x,Ex,Theta,Sigma2){ #par:initial value
        -exp(eval(Ex,envir=list(x=matrix(x,1,length(x)),theta=Theta,sigma2=Sigma2)))/dmvnorm(x)
    },Ex=Ex,Theta=Theta,Sigma2=Sigma2)$value)
    X <- NULL
    i <- 1
    pb <- txtProgressBar(1,n.sample,style = 3)
    while(i<=n.sample){
        u <- runif(1)
        y <- rmvnorm(1,mean=rep(0,d))
        if(M*dmvnorm(y[1,])*u<=
           exp(eval(Ex,envir=list(x=y,theta=Theta,sigma2=Sigma2)))
           ){
            X <- rbind(X,y)
            setTxtProgressBar(pb,i)
            i <- i+1}
    }
    as.data.frame(X)
}
}
