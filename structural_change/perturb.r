# perturb state variables

# 1.perturb graph
# Talih 4.1
toggle.move <- function(complete,g,specified=NULL){
    #complete: complete graph, generated by generate.ug()
    #specified: specific edge to be toggled, used in fork move
    ne <- length(E(complete$ug))        #number of edges
    #the edge to be used in toggle move
    if(length(specified)==0)
        te <- random.edge(rep(FALSE,ne))
    else
        te <- specified
    ilist=sapply(g$ilist,function(.data,e){
        xor(.data,e)
    },e=te,simplify = FALSE)
    list(glist=llply(ilist,function(.data,Graph,No.edges){
            subgraph.edges(Graph,(1:No.edges)[.data],
                           delete.vertices = FALSE)
        },Graph=complete$ug,No.edges=ne),
         ilist=ilist)
}
fork.move <- function(complete,g,B){
    #complete: complete graph, generated by generate.ug()
    #g: previous graph list
    #B: number of blocks
    #b: fork start at index b
    b <- ceiling(runif(1,1,B))
    ue <- g$ilist[[b]]!=g$ilist[[b-1]] #edge to be untoggled
    toggle <- toggle.move(complete,list(glist=g$glist[b:B],
                                        ilist=g$ilist[b:B]))
    untoggle <- toggle.move(complete,toggle,specified=ue)
    g$glist[b:B] <- untoggle$glist
    g$ilist[b:B] <- untoggle$ilist
    g
}
perturb.g <- function(complete,g,B){
    if(runif(1)>0.5)
        return(toggle.move(complete,g))
    else
        return(fork.move(complete,g,B))
}

# 2.perturb m
# Talih 4.2
perturb.m <- function(m){
    B <- length(m)
    b <- ceiling(runif(1,0,B-1))
    tmp <- sum(m[b:(b+1)])
    m[b] <- round(tmp*runif(1))
    m[b+1] <- tmp-m[b]
    m
}

# 3.perturb theta and sigma2 (hierarchical on tan or log scale)
# Talih 3.3.2 & 4.3
hierarchy <- function(initial,psi,length.out){
    if(length.out==1) return(initial)
    res <- initial
    phi <- psi[1];alpha <- psi[2];eta2 <- psi[3]
    epsilon <- rnorm(length.out-1,mean=(1-phi)*alpha,sd=sqrt(eta2))
    for(i in 2:length.out)
        res[i] <- res[i-1]*phi+epsilon[i-1]
    res
}
perturb.theta <- function(ThetaB,B,psi,zeta=0.9){
    # zeta: tunning parameter
    if(runif(1)>0.5){ #toggle
        initial <- tan(ThetaB[1]*pi/2)+rnorm(1,sd=zeta)
        return(atan(hierarchy(initial,psi,B))/pi*2)
    }
    else{             #fork
        b <- ceiling(runif(1,1,B))
        initial <- tan(ThetaB[b]*pi/2)+rnorm(1,sd=zeta)
        return(c(ThetaB[1:(b-1)],
                 atan(hierarchy(initial,psi,B-b+1))/pi*2))
    }
}
perturb.sigma2 <- function(Sigma2B,B,psi,zeta=0.25){
    # zeta: tunning parameter
    if(runif(1)>0.5){ #toggle
        initial <- log(Sigma2B[1])+rnorm(1,sd=zeta)
        return(exp(hierarchy(initial,psi,B)))
    }
    else{             #fork
        b <- ceiling(runif(1,1,B))
        initial <- log(Sigma2B[b])+rnorm(1,sd=zeta)
        return(c(Sigma2B[1:(b-1)],
                 exp(hierarchy(initial,psi,B-b+1))))
    }
}

# 4.perturb psi theta and psi sigma2
# Talih 4.3.3
# zeta=1.3 for theta; zeta=1.1 for sigma2
perturb.psitheta <- function(psi,zeta=1.3){
    # zeta: tunning parameter
    # psi: phi,alpha,eta
    c(
        atan(tan(psi[1]*pi/2)+rnorm(1,sd=zeta))/pi*2, #phi
        psi[2]+rnorm(1,sd=zeta),                      #alpha
        exp(log(psi[3])+rnorm(1,sd = zeta))           #eta
        )
}
perturb.psisigma2 <- function(psi,zeta=1.1){
    # zeta: tunning parameter
    # psi: phi,alpha,eta
    c(
        atan(tan(psi[1]*pi/2)+rnorm(1,sd=zeta))/pi*2, #phi
        psi[2]+rnorm(1,sd=zeta),                      #alpha
        exp(log(psi[3])+rnorm(1,sd = zeta))           #eta
        )
}
